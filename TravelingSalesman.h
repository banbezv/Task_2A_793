#pragma once
/*
Построение пути коммивояжера:
Строим минимальное остовное дерево. Помечаем все вершины дерева непосещёнными (кроме 0-й). Считаем 0-ю last вершиной
Проходим его алгоритмом dfs:
	если текущая вершина непосещена, то связываем её ребром с last вершиной (вес берём из оригинального графа). Считаем last вершиной эту.
Соединяем последнюю и первую вершуну обхода. Длина полученного цикла не превосходит удвоенной кратчайшей длины пути
коммивояжера в этом графе.
Доказательство:
Итоговая длина не превосходит удвоенного веса минимального остовного дерева (по неравенству треугольника каждое добавленное
рёбро по длине не превышает длину пути по последовательно пройденным вершинам в dfs между вершинами добавленноего ребра, т.е.
итоговая длина не превышает длину пути обхода дерева алгоритмом dfs от корня к корню (полный круг по дереву), которая равна
удвоенному весу этого дерева), который (неудвоенный вес) является нижней границей оценки длины минимального цикла коммивояжера.
Качество приближения Lполуч/Lистин<=2
*/
#include<stack>
#include"graph.h"
#include"MinSpanTree.h"
using namespace std;
class TravelingSalesman {
private:
	GraphMatrix1D graph, circle; // исходный граф и полученный цикл коммивояжера
	double length; // длина цикла
public:
	explicit TravelingSalesman( const GraphMatrix1D &mxcpy );
	explicit TravelingSalesman( const TravelingSalesman& socpy );
	TravelingSalesman( TravelingSalesman&& mov );
	TravelingSalesman& operator=( const TravelingSalesman& socpy );
	const GraphMatrix1D& GetGraph( ) const; // получение исходного графа
	const GraphMatrix1D& GetCircleGraph( ) const; // получение итогового цикла
	double GetLength( ) const; // получение длины цикла
	void BuildCircleGraph( ); // поиск цикла коммивояжера в приближении 2
};
